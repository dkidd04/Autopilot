package com.citigroup.liquifi.autopilot.gui;

import java.awt.Cursor;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.swing.DefaultComboBoxModel;
import javax.swing.DropMode;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.ListSelectionModel;
import javax.swing.RowFilter;
import javax.swing.SwingWorker;
import javax.swing.TransferHandler;
import javax.swing.SwingWorker.StateValue;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import com.citigroup.liquifi.AutoPilotAppl;
import com.citigroup.liquifi.autopilot.bootstrap.ApplicationContext;
import com.citigroup.liquifi.autopilot.controller.TestCaseController;
import com.citigroup.liquifi.autopilot.controller.ValidationObject;
import com.citigroup.liquifi.autopilot.gui.model.TestTableModel;
import com.citigroup.liquifi.autopilot.logger.AceLogger;
import com.citigroup.liquifi.entities.LFCategory;
import com.citigroup.liquifi.entities.LFLabel;
import com.citigroup.liquifi.entities.LFOutputMsg;
import com.citigroup.liquifi.entities.LFOutputTag;
import com.citigroup.liquifi.entities.LFTag;
import com.citigroup.liquifi.entities.LFTestCase;
import com.citigroup.liquifi.entities.LFTestInputSteps;
import com.citigroup.liquifi.util.DBUtil;
import com.citigroup.liquifi.util.Util;

import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.JScrollPane;

import com.citigroup.liquifi.autopilot.gui.dndTree.*;
import java.awt.Component;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.border.SoftBevelBorder;
import javax.swing.border.BevelBorder;
import javax.swing.border.TitledBorder;
import javax.swing.JCheckBox;
import java.awt.event.ActionListener;

/**
 * 
 * @author zy63334
 */
public class TestRunPanel extends javax.swing.JPanel implements	PropertyChangeListener {
	private static final long serialVersionUID = 1L;
	private AceLogger logger = AceLogger.getLogger(this.getClass().getSimpleName());

	/** Creates new form TestRunPanel */
	public TestRunPanel() {
		setBorder(new TitledBorder(null, "", TitledBorder.LEADING,
				TitledBorder.TOP, null, null));
		initComponents();
		init();

	}

	private void init() {
		filterPanel.setVisible(false);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {
		hourglassCursor = new Cursor(Cursor.WAIT_CURSOR);
		defaultCursor = new Cursor(Cursor.DEFAULT_CURSOR);
		testRunDialog = new javax.swing.JDialog();
		okRunDialogButton = new javax.swing.JButton();
		titleLabel = new javax.swing.JLabel();
		passLabel = new javax.swing.JLabel();
		passNumLabel = new javax.swing.JLabel();
		failLabel = new javax.swing.JLabel();
		failNumLabel = new javax.swing.JLabel();
		resultTablePopupMenu = new javax.swing.JPopupMenu();
		editMenuItem = new javax.swing.JMenuItem();
		copyMenuItem = new javax.swing.JMenuItem();
		pasteMenuItem = new javax.swing.JMenuItem();
		cutMenuItem = new javax.swing.JMenuItem();
		deleteMenuItem = new javax.swing.JMenuItem();
		removeFromLabelMenuItem = new javax.swing.JMenuItem();
		//renameLabelMenuItem = new javax.swing.JMenuItem();
		// copySelectedCasesMenuItem = new javax.swing.JMenuItem();
		addNewCategoryMenuItem = new javax.swing.JMenuItem();
		removeCategoryMenuItem = new javax.swing.JMenuItem();
		renameTreeNodeMenuItem = new javax.swing.JMenuItem();
		addNewLabelMenuItem = new javax.swing.JMenuItem();
		removeLabelMenuItem = new javax.swing.JMenuItem();
		renameLabelMenuItem = new javax.swing.JMenuItem();
		// pasteSelectedCasesMenuItem = new javax.swing.JMenuItem();
		mainFilterLabel = new javax.swing.JLabel();
		mainFilterComboBox = new javax.swing.JComboBox();
		searchTextField = new javax.swing.JTextField();
		searchButton = new javax.swing.JButton();
		resultScrollPane = new javax.swing.JScrollPane();
		resultTable = new javax.swing.JTable();
		resultTable.setRowSelectionAllowed(true);
		resultTable
				.setSelectionMode(javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		resultTable.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getClickCount() == 2) {
					doubleClickTestCasePerformed(e);
				}
			}
		});
		resultTable.setDragEnabled(true);
		tableProgressbarSeparator = new javax.swing.JSeparator();
		testProgressBar = new javax.swing.JProgressBar();
		enableAllCheckBox = new javax.swing.JCheckBox();
		passLabel1 = new javax.swing.JLabel();
		passNumLabel1 = new javax.swing.JLabel();
		failLabel1 = new javax.swing.JLabel();
		failNumLabel1 = new javax.swing.JLabel();
		symbolLabel = new javax.swing.JLabel();
		symbolTextField = new javax.swing.JTextField();
		filterPanel = new javax.swing.JPanel();
		jLabel1 = new javax.swing.JLabel();
		jComboBox2 = new javax.swing.JComboBox();
		jTextField1 = new javax.swing.JTextField();
		jLabel2 = new javax.swing.JLabel();
		jLabel3 = new javax.swing.JLabel();
		jComboBox3 = new javax.swing.JComboBox();
		jComboBox4 = new javax.swing.JComboBox();
		jTextField2 = new javax.swing.JTextField();
		jTextField3 = new javax.swing.JTextField();
		showFilterPanel = new javax.swing.JToggleButton();

		testRunDialog.setName("testRunDialog"); // NOI18N

		okRunDialogButton.setText("OK");
		okRunDialogButton.setName("okRunDialogButton"); // NOI18N
		okRunDialogButton
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						okRunDialogButtonActionPerformed(evt);
					}
				});

		titleLabel.setFont(new java.awt.Font("Tahoma 11", 1, 12)); // NOI18N
		titleLabel.setText("Run finished - Current result of the run");
		titleLabel.setName("titleLabel"); // NOI18N

		passLabel.setText("Pass:");
		passLabel.setName("passLabel"); // NOI18N

		passNumLabel.setFont(new java.awt.Font("Tahoma 12", 1, 12)); // NOI18N
		passNumLabel.setForeground(new java.awt.Color(0, 204, 102));
		passNumLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		passNumLabel.setName("passNumLabel"); // NOI18N

		failLabel.setText("Fail:");
		failLabel.setName("failLabel"); // NOI18N

		failNumLabel.setFont(new java.awt.Font("Tahoma 12", 1, 12)); // NOI18N
		failNumLabel.setForeground(new java.awt.Color(255, 0, 0));
		failNumLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		failNumLabel.setName("failNumLabel"); // NOI18N

		javax.swing.GroupLayout testRunDialogLayout = new javax.swing.GroupLayout(
				testRunDialog.getContentPane());
		testRunDialog.getContentPane().setLayout(testRunDialogLayout);
		testRunDialogLayout
				.setHorizontalGroup(testRunDialogLayout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								testRunDialogLayout
										.createSequentialGroup()
										.addGroup(
												testRunDialogLayout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.LEADING)
														.addGroup(
																testRunDialogLayout
																		.createSequentialGroup()
																		.addGap(77,
																				77,
																				77)
																		.addGroup(
																				testRunDialogLayout
																						.createParallelGroup(
																								javax.swing.GroupLayout.Alignment.TRAILING)
																						.addComponent(
																								passLabel)
																						.addComponent(
																								failLabel))
																		.addGap(18,
																				18,
																				18)
																		.addGroup(
																				testRunDialogLayout
																						.createParallelGroup(
																								javax.swing.GroupLayout.Alignment.LEADING,
																								false)
																						.addComponent(
																								failNumLabel,
																								javax.swing.GroupLayout.DEFAULT_SIZE,
																								javax.swing.GroupLayout.DEFAULT_SIZE,
																								Short.MAX_VALUE)
																						.addComponent(
																								passNumLabel,
																								javax.swing.GroupLayout.DEFAULT_SIZE,
																								96,
																								Short.MAX_VALUE)))
														.addGroup(
																testRunDialogLayout
																		.createSequentialGroup()
																		.addGap(54,
																				54,
																				54)
																		.addComponent(
																				titleLabel,
																				javax.swing.GroupLayout.PREFERRED_SIZE,
																				234,
																				javax.swing.GroupLayout.PREFERRED_SIZE))
														.addGroup(
																testRunDialogLayout
																		.createSequentialGroup()
																		.addGap(130,
																				130,
																				130)
																		.addComponent(
																				okRunDialogButton)))
										.addContainerGap(46, Short.MAX_VALUE)));
		testRunDialogLayout
				.setVerticalGroup(testRunDialogLayout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								testRunDialogLayout
										.createSequentialGroup()
										.addGap(28, 28, 28)
										.addComponent(
												titleLabel,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												30,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addGap(33, 33, 33)
										.addGroup(
												testRunDialogLayout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(passLabel)
														.addComponent(
																passNumLabel,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																24,
																javax.swing.GroupLayout.PREFERRED_SIZE))
										.addGap(30, 30, 30)
										.addGroup(
												testRunDialogLayout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(failLabel)
														.addComponent(
																failNumLabel,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																24,
																javax.swing.GroupLayout.PREFERRED_SIZE))
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED,
												42, Short.MAX_VALUE)
										.addComponent(okRunDialogButton)
										.addGap(51, 51, 51)));

		resultTablePopupMenu.setName("resultTablePopupMenu"); // NOI18N

		editMenuItem.setText("Edit");
		editMenuItem.setToolTipText("Edit");
		editMenuItem.setName("editMenuItem"); // NOI18N
		editMenuItem.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				editMenuItemActionPerformed(evt);
			}
		});
		resultTablePopupMenu.add(editMenuItem);
		resultTablePopupMenu.addPopupMenuListener(new PopupMenuListener() {

			public void popupMenuCanceled(PopupMenuEvent e) {
			}

			public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
			}

			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
				int selectedRow = resultTable.rowAtPoint(resultTable
						.getMousePosition());
				ListSelectionModel model = resultTable.getSelectionModel();
				model.setSelectionInterval(selectedRow, selectedRow);
			}
		});

		copyMenuItem.setText("Copy");
		copyMenuItem.setToolTipText("Copy");
		copyMenuItem.setEnabled(false);
		copyMenuItem.setName("copyMenuItem"); // NOI18N
		resultTablePopupMenu.add(copyMenuItem);

		pasteMenuItem.setText("Paste");
		pasteMenuItem.setToolTipText("Paste");
		pasteMenuItem.setEnabled(false);
		pasteMenuItem.setName("pasteMenuItem"); // NOI18N
		resultTablePopupMenu.add(pasteMenuItem);

		cutMenuItem.setText("Cut");
		cutMenuItem.setToolTipText("Cut");
		cutMenuItem.setEnabled(false);
		cutMenuItem.setName("cutMenuItem"); // NOI18N
		resultTablePopupMenu.add(cutMenuItem);

		deleteMenuItem.setText("Delete");
		deleteMenuItem.setToolTipText("Delete");
		deleteMenuItem.setName("deleteMenuItem"); // NOI18N
		deleteMenuItem.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				deleteMenuItemActionPerformed(evt);
			}
		});
		resultTablePopupMenu.add(deleteMenuItem);

		removeFromLabelMenuItem.setText("Remove Selected Test Case From Label");
		removeFromLabelMenuItem
				.setToolTipText("Remove the selected test case(s) from label");
		removeFromLabelMenuItem.setName("removeFromLabelMenuItem"); // NOI18N
		removeFromLabelMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						removeFromLabelMenuItemActionPerformed(evt);
					}
				});
		resultTablePopupMenu.add(removeFromLabelMenuItem);

		
		
		setAutoscrolls(true);
		setDoubleBuffered(false);
		setName("Form"); // NOI18N

		mainFilterLabel.setText("Filter 1:");
		mainFilterLabel.setName("mainFilterLabel"); // NOI18N

		mainFilterComboBox.setModel(new DefaultComboBoxModel(ApplicationContext
				.getConfig().getQueryCriteria()));
		mainFilterComboBox.setName("criteriaComboBox"); // NOI18N
		mainFilterComboBox
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						criteriaComboBoxActionPerformed(evt);
					}
				});

		searchTextField.setName("searchTextField"); // NOI18N
		searchTextField.addKeyListener(new KeyAdapter() {

			public void keyReleased(KeyEvent e) {
				if (KeyEvent.VK_ENTER == e.getKeyCode()) {
					loadTestCases(true);
				}
			}

		});
		searchButton.setText("Search");
		searchButton.setName("searchButton"); // NOI18N
		searchButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				searchButtonActionPerformed(evt);
			}
		});

		resultScrollPane.setName("resultScrollPane"); // NOI18N

		resultTable.setModel(tableModel);
		resultTable.setName("resultTable"); // NOI18N
		resultTable.setTransferHandler(new TableTransferHandler());
		TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel>(
				resultTable.getModel());
		resultTable.setRowSorter(sorter);
		resultTable.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseReleased(java.awt.event.MouseEvent evt) {
				resultTableMouseReleased(evt);
			}
		});
		resultScrollPane.setViewportView(resultTable);

		tableProgressbarSeparator.setName("tableProgressbarSeparator"); // NOI18N

		testProgressBar.setToolTipText("Progress");
		testProgressBar.setName("testProgressBar"); // NOI18N
		testProgressBar.setStringPainted(true);

		enableAllCheckBox.setText("Enable All");
		enableAllCheckBox.setName("enableAllCheckBox"); // NOI18N
		enableAllCheckBox
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						enableAllCheckBoxActionPerformed(evt);
					}
				});

		passLabel1.setText("Pass:");
		passLabel1.setName("passLabel1"); // NOI18N

		passNumLabel1.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
		passNumLabel1.setForeground(new java.awt.Color(0, 153, 51));
		passNumLabel1.setText("0");
		passNumLabel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		passNumLabel1.setName("passNumLabel1"); // NOI18N

		failLabel1.setText("Fail:");
		failLabel1.setName("failLabel1"); // NOI18N

		failNumLabel1.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
		failNumLabel1.setForeground(new java.awt.Color(255, 0, 51));
		failNumLabel1.setText("0");
		failNumLabel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		failNumLabel1.setName("failNumLabel1"); // NOI18N

		symbolLabel.setText("Symbol");
		symbolLabel.setName("symbolLabel"); // NOI18N

		symbolTextField.setName("symbolTextField"); // NOI18N

		filterPanel.setBorder(javax.swing.BorderFactory
				.createLineBorder(new java.awt.Color(153, 153, 153)));
		filterPanel.setName("filterPanel"); // NOI18N

		jLabel1.setText("Filter 2:");
		jLabel1.setName("jLabel1"); // NOI18N

		jComboBox2.setModel(new DefaultComboBoxModel(ApplicationContext
				.getConfig().getQueryCriteria()));
		if (jComboBox2.getItemCount() > 1) {
			jComboBox2.setSelectedIndex(1);
		}
		jComboBox2.setName("jComboBox1"); // NOI18N

		jTextField1.setName("jTextField1"); // NOI18N

		jLabel2.setText("Filter 3:");
		jLabel2.setName("jLabel2"); // NOI18N

		jLabel3.setText("Filter 4:");
		jLabel3.setName("jLabel3"); // NOI18N

		jComboBox3.setModel(new DefaultComboBoxModel(ApplicationContext
				.getConfig().getQueryCriteria()));
		if (jComboBox3.getItemCount() > 2) {
			jComboBox3.setSelectedIndex(2);
		}
		jComboBox3.setName("jComboBox2"); // NOI18N

		jComboBox4.setModel(new DefaultComboBoxModel(ApplicationContext
				.getConfig().getQueryCriteria()));
		if (jComboBox4.getItemCount() > 3) {
			jComboBox4.setSelectedIndex(3);
		}
		jComboBox4.setName("jComboBox3"); // NOI18N

		jTextField2.setName("jTextField2"); // NOI18N

		jTextField3.setName("jTextField3"); // NOI18N

		javax.swing.GroupLayout filterPanelLayout = new javax.swing.GroupLayout(
				filterPanel);
		filterPanel.setLayout(filterPanelLayout);
		filterPanelLayout
				.setHorizontalGroup(filterPanelLayout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								filterPanelLayout
										.createSequentialGroup()
										.addContainerGap()
										.addComponent(jLabel1)
										.addGap(18, 18, 18)
										.addComponent(
												jComboBox2,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												91,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addGap(18, 18, 18)
										.addComponent(
												jTextField1,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												95,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addGap(59, 59, 59)
										.addComponent(jLabel2)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addComponent(
												jComboBox3,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												91,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addGap(18, 18, 18)
										.addComponent(
												jTextField2,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												95,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addGap(65, 65, 65)
										.addComponent(jLabel3)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addComponent(
												jComboBox4,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												91,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
										.addComponent(
												jTextField3,
												javax.swing.GroupLayout.PREFERRED_SIZE,
												95,
												javax.swing.GroupLayout.PREFERRED_SIZE)
										.addContainerGap(91, Short.MAX_VALUE)));
		filterPanelLayout
				.setVerticalGroup(filterPanelLayout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								filterPanelLayout
										.createSequentialGroup()
										.addContainerGap()
										.addGroup(
												filterPanelLayout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(jLabel1)
														.addComponent(
																jComboBox2,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																javax.swing.GroupLayout.DEFAULT_SIZE,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(
																jComboBox3,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																javax.swing.GroupLayout.DEFAULT_SIZE,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(
																jTextField1,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																21,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(
																jTextField2,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																21,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(
																jComboBox4,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																javax.swing.GroupLayout.DEFAULT_SIZE,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(
																jTextField3,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																javax.swing.GroupLayout.DEFAULT_SIZE,
																javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(jLabel2)
														.addComponent(jLabel3))
										.addContainerGap(
												javax.swing.GroupLayout.DEFAULT_SIZE,
												Short.MAX_VALUE)));

		showFilterPanel.setText("Filter Options");
		showFilterPanel.setName("showFilters"); // NOI18N
		showFilterPanel.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				filterButtonActionPerformed(evt);
			}
		});

		folderTree_scrollPane = new JScrollPane();
		folderTree_scrollPane.setAlignmentX(Component.RIGHT_ALIGNMENT);
		folderTree_scrollPane.setEnabled(true);
		folderTree_scrollPane.setVisible(true);

		panel = new JPanel();
		panel.setBorder(new SoftBevelBorder(BevelBorder.LOWERED, null, null,
				null, null));
		panel.setVisible(true);

		chckbxEnableResultWindow = new JCheckBox();
		chckbxEnableResultWindow.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				chckbxEnableResultWindowActionPerformed(evt);
			}
		});
		chckbxEnableResultWindow.setText("Enable Result Window");
		chckbxEnableResultWindow.setName("enableAllCheckBox");

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		layout.setHorizontalGroup(layout
				.createParallelGroup(Alignment.TRAILING)
				.addGroup(
						layout.createSequentialGroup()
								.addContainerGap()
								.addGroup(
										layout.createParallelGroup(
												Alignment.LEADING)
												.addComponent(
														filterPanel,
														GroupLayout.DEFAULT_SIZE,
														1126, Short.MAX_VALUE)
												.addComponent(
														testProgressBar,
														GroupLayout.DEFAULT_SIZE,
														1126, Short.MAX_VALUE)
												.addComponent(
														tableProgressbarSeparator,
														GroupLayout.PREFERRED_SIZE,
														1126, Short.MAX_VALUE)
												.addGroup(
														layout.createSequentialGroup()
																.addComponent(
																		mainFilterLabel,
																		GroupLayout.PREFERRED_SIZE,
																		66,
																		GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(
																		ComponentPlacement.RELATED)
																.addComponent(
																		mainFilterComboBox,
																		GroupLayout.PREFERRED_SIZE,
																		74,
																		GroupLayout.PREFERRED_SIZE)
																.addGap(18)
																.addComponent(
																		searchTextField,
																		GroupLayout.PREFERRED_SIZE,
																		281,
																		GroupLayout.PREFERRED_SIZE)
																.addGap(18)
																.addComponent(
																		searchButton)
																.addPreferredGap(
																		ComponentPlacement.UNRELATED)
																.addComponent(
																		showFilterPanel)
																.addGap(10)
																.addComponent(
																		enableAllCheckBox)
																.addGap(18)
																.addComponent(
																		passLabel1)
																.addPreferredGap(
																		ComponentPlacement.RELATED)
																.addComponent(
																		passNumLabel1,
																		GroupLayout.PREFERRED_SIZE,
																		53,
																		GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(
																		ComponentPlacement.RELATED)
																.addComponent(
																		failLabel1)
																.addPreferredGap(
																		ComponentPlacement.RELATED)
																.addComponent(
																		failNumLabel1,
																		GroupLayout.PREFERRED_SIZE,
																		52,
																		GroupLayout.PREFERRED_SIZE)
																.addGap(18)
																.addComponent(
																		symbolLabel)
																.addPreferredGap(
																		ComponentPlacement.UNRELATED)
																.addComponent(
																		symbolTextField,
																		GroupLayout.PREFERRED_SIZE,
																		71,
																		GroupLayout.PREFERRED_SIZE)
																.addGap(18)
																.addComponent(
																		chckbxEnableResultWindow))
												.addGroup(
														layout.createSequentialGroup()
																.addGroup(
																		layout.createParallelGroup(
																				Alignment.TRAILING,
																				false)
																				.addComponent(
																						folderTree_scrollPane)
																				.addComponent(
																						panel,
																						GroupLayout.DEFAULT_SIZE,
																						236,
																						Short.MAX_VALUE))
																.addPreferredGap(
																		ComponentPlacement.UNRELATED)
																.addComponent(
																		resultScrollPane,
																		GroupLayout.DEFAULT_SIZE,
																		880,
																		Short.MAX_VALUE)))
								.addContainerGap()));
		layout.setVerticalGroup(layout
				.createParallelGroup(Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addContainerGap()
								.addGroup(
										layout.createParallelGroup(
												Alignment.BASELINE)
												.addComponent(enableAllCheckBox)
												.addComponent(passLabel1)
												.addComponent(failLabel1)
												.addComponent(
														passNumLabel1,
														GroupLayout.PREFERRED_SIZE,
														21,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														failNumLabel1,
														GroupLayout.PREFERRED_SIZE,
														23,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(symbolLabel)
												.addComponent(
														symbolTextField,
														GroupLayout.PREFERRED_SIZE,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														mainFilterLabel,
														GroupLayout.PREFERRED_SIZE,
														29,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														mainFilterComboBox,
														GroupLayout.PREFERRED_SIZE,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														searchTextField,
														GroupLayout.PREFERRED_SIZE,
														28,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														searchButton,
														GroupLayout.PREFERRED_SIZE,
														24,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(showFilterPanel)
												.addComponent(
														chckbxEnableResultWindow))
								.addPreferredGap(ComponentPlacement.RELATED)
								.addComponent(filterPanel,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(ComponentPlacement.RELATED)
								.addGroup(
										layout.createParallelGroup(
												Alignment.LEADING)
												.addGroup(
														layout.createSequentialGroup()
																.addComponent(
																		panel,
																		GroupLayout.PREFERRED_SIZE,
																		GroupLayout.DEFAULT_SIZE,
																		GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(
																		ComponentPlacement.RELATED)
																.addComponent(
																		folderTree_scrollPane,
																		GroupLayout.DEFAULT_SIZE,
																		540,
																		Short.MAX_VALUE))
												.addComponent(
														resultScrollPane,
														GroupLayout.DEFAULT_SIZE,
														576, Short.MAX_VALUE))
								.addGap(11)
								.addComponent(tableProgressbarSeparator,
										GroupLayout.PREFERRED_SIZE, 10,
										GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(ComponentPlacement.RELATED)
								.addComponent(testProgressBar,
										GroupLayout.PREFERRED_SIZE, 27,
										GroupLayout.PREFERRED_SIZE)
								.addContainerGap()));

		JLabel lblTestCaseCategory = new JLabel("Test Case Category Manager");
		lblTestCaseCategory.setAlignmentX(Component.CENTER_ALIGNMENT);
		panel.add(lblTestCaseCategory);

		// testCaseTree = new AutoScrollingJTree();
		testCaseTree = new JTree();
		testCaseTree.setEditable(false);
		testCaseTree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
		testCaseTree.setDropMode(DropMode.ON);
		testCaseTree.setDragEnabled(true);
		testCaseTree.setTransferHandler(new TreeTransferHandler());
		// testCaseTree.setDragEnabled(true);
		testCaseTree
				.addTreeSelectionListener(new TestCaseTreeSelectionListener());
		testCaseTree.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseReleased(java.awt.event.MouseEvent evt) {
				testCaseTreeMouseReleased(evt);
			}
		});
		// caseFolderTree.setDropMode(DropMode.ON_OR_INSERT);

		testCaseTree.setCellRenderer(new DefaultTreeCellRenderer() {
			@Override
			public Component getTreeCellRendererComponent(JTree tree,
					Object value, boolean sel, boolean expanded, boolean leaf,
					int row, boolean hasFocus) {

				// Call parent rendering to keep the default behaviour
				super.getTreeCellRendererComponent(tree, value, sel, expanded,
						leaf, row, hasFocus);

				// And now specific stuff
				TestCaseTreeNode node = (TestCaseTreeNode) value;
				// If the current node is a directory, and if it has no child,
				// or if they are not accessible, change the icon.
				if (node.getType() == TestCaseTreeNode.NodeType.LABEL
						|| node.getType() == TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY) {
					setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/label.png")));
				} else if (node.getType() == TestCaseTreeNode.NodeType.LABEL_FOLDER) {
					setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/labels.png")));
				} else if (node.getType() == TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY) {
					this.setToolTipText("Simply drag the label to the result table to filter the results.");
				} else if (node.getType() == TestCaseTreeNode.NodeType.RELEASE_NUM_DIR){
						setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/releaseNum2.png")));
				} else if (node.getType() == TestCaseTreeNode.NodeType.JIRA_NUM_NODE){
						setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/releaseNum2.png")));
				} else if (node.getType() == TestCaseTreeNode.NodeType.JIRA_NUM_DIR){
						setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/releaseNum2.png")));
				}else if (node.getType() == TestCaseTreeNode.NodeType.RELEASE_NUM_NODE){
						setIcon(new javax.swing.ImageIcon(
							getClass()
									.getResource(
											"/com/citigroup/liquifi/autopilot/gui/resources/icons/releaseNum1.png")));
				}else {
					if (expanded) {
						setIcon(openIcon);
					} else {
						setIcon(closedIcon);
					}

				}

				return this;
			}
		});

		rootNode = new TestCaseTreeNode("Test Case Categories",
				TestCaseTreeNode.NodeType.ROOT);
		testCaseTree.setModel(new DefaultTreeModel(rootNode));
		testCaseTree.getModel().addTreeModelListener(
				new TestCaseTreeModelChangedListener());

		treePopupMenu = new JPopupMenu();
		addNewCategoryMenuItem.setText("Add New Category");
		addNewCategoryMenuItem.setName("addNewCategoryMenuItem"); // NOI18N
		addNewCategoryMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						addNewCaseCategoryActionPerformed(evt);
					}
				});
		treePopupMenu.add(addNewCategoryMenuItem);

		removeCategoryMenuItem.setText("Remove Category");
		removeCategoryMenuItem.setName("addNewCategoryMenuItem"); // NOI18N
		removeCategoryMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						removeCaseCategoryActionPerformed(evt);
					}
				});
		treePopupMenu.add(removeCategoryMenuItem);

		renameTreeNodeMenuItem.setText("Rename");
		renameTreeNodeMenuItem.setName("renameTreeNodeMenuItem"); // NOI18N
		renameTreeNodeMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						renameTreeNodeMenuItemActionPerformed(evt);
					}
				});
		treePopupMenu.add(renameTreeNodeMenuItem);

		addNewLabelMenuItem.setText("Add New Label");
		addNewLabelMenuItem.setName("addNewCategoryMenuItem"); // NOI18N
		addNewLabelMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						addNewLabelMenuItemActionPerformed(evt);
					}
				});
		treePopupMenu.add(addNewLabelMenuItem);

		removeLabelMenuItem.setText("Delete Label");
		removeLabelMenuItem.setName("removeLabelMenuItem"); // NOI18N
		removeLabelMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						removeLabelMenuItemActionPerformed(evt);
					}
				});
		treePopupMenu.add(removeLabelMenuItem);
		
		renameLabelMenuItem.setText("Rename Label");
		renameLabelMenuItem.setName("renameLabelMenuItem"); // NOI18N
		renameLabelMenuItem
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						renameLabelMenuItemActionPerformed(evt);
					}
				});
		treePopupMenu.add(renameLabelMenuItem);

		testCaseTree.add(treePopupMenu);
		folderTree_scrollPane.setViewportView(testCaseTree);
		this.setLayout(layout);
	}// </editor-fold>//GEN-END:initComponents

	protected void renameLabelMenuItemActionPerformed(ActionEvent evt) {
		// TODO Auto-generated method stub
		// create new label
		TestCaseTreeNode newLabelNode = renameOldLabel();
		
		//move all the older label test cases to new label
		
		TreePath currentSelection = testCaseTree.getSelectionPath();
		if (currentSelection != null && newLabelNode != null) {
			String newLabelName = newLabelNode.getLabel().getLabel();
			TestCaseTreeNode currentNode = (TestCaseTreeNode) (currentSelection
					.getLastPathComponent());
			Set<LFTestCase> casesInLabel = DBUtil.getInstance()
					.getTestCasesForLabel(currentNode.getLabel().getLabel());
		
			Iterator<LFTestCase> iterator = casesInLabel.iterator();
			while(iterator.hasNext()) {
					
			        LFTestCase setElement = iterator.next();
			        try {
						DBUtil.getInstance()
								.getLbm()
								.removeLabelFromTestcase(
										currentNode.getLabel().getLabel(),
										setElement.getTestID());
					
					} catch (Exception e) {
						e.printStackTrace();
					}
			        addTestCaseToLabel(newLabelName,setElement);
			        incrementNodeCount(newLabelName);
			                
			    }
			// remove old label
			removeLabel();
			// create a pop up to notify user on successful renaming
			final JFrame frame = new JFrame();
			JOptionPane.showMessageDialog(frame, "Label Renamed Successfully!!!");
			
		}
		else
		{
			final JFrame frame = new JFrame();
			JOptionPane.showMessageDialog(frame, "Label renaming failed :(");
			logger.info("ERROR WHILE RENAMING LABEL");
			if(currentSelection == null)
			{
				logger.info("ERROR current selection is null");
				logger.info("Removing new label since there was error creating it");
				removeLabel(newLabelNode);
			}
			if(newLabelNode == null)
			{
				logger.info("ERROR creating new label");
			}
			
			
		}
		
		
	}
	public TestCaseTreeNode renameOldLabel() {
		String labelName = (String) JOptionPane.showInputDialog(AutoPilotAppl
				.getApplication().getMainFrame(),
				"Please enter the new name of label", "Renamed Label",
				JOptionPane.QUESTION_MESSAGE, null, null, "");

		LFLabel newLabel = new LFLabel(labelName);
		newLabel.setLabelID(Util.getLabelIDSequencer());
		TestCaseTreeNode newLabelNode = new TestCaseTreeNode(newLabel);
		if (isValidNewNode(newLabelNode)) {
			addNewLabelToFolderTree(newLabelNode);
			addNewLabelToPersistence(newLabelNode);
		} else {
			JOptionPane
					.showMessageDialog(AutoPilotAppl.getApplication()
							.getMainFrame(),
							"Invalid category name or category is already existed, please try again.");
			return null;
		}

		return newLabelNode;
	}

	protected void chckbxEnableResultWindowActionPerformed(ActionEvent evt) {
		if (chckbxEnableResultWindow.isSelected()) {
			this.isResultTableEnabled = true;
		} else {
			this.isResultTableEnabled = false;
		}

	}

	protected void removeLabelMenuItemActionPerformed(ActionEvent evt) {
		removeLabel();
	}

	protected void removeLabel() {

		TreePath currentSelection = testCaseTree.getSelectionPath();
		if (currentSelection != null) {
			TestCaseTreeNode currentNode = (TestCaseTreeNode) (currentSelection
					.getLastPathComponent());
			Set<LFTestCase> casesInLabel = DBUtil.getInstance()
					.getTestCasesForLabel(currentNode.getLabel().getLabel());
			if (casesInLabel != null && casesInLabel.size() > 0) {
				JOptionPane
						.showMessageDialog(
								AutoPilotAppl.getApplication().getMainFrame(),
								"Cannot delete a label with test cases in it, please move all test cases to another category before removing it.");
			} else {
				removeLabelFromFolderTree(currentNode);
				removeLabelFromPersistence(currentNode);
			}
		}
	}
	protected void removeLabel(TestCaseTreeNode currentNode) {

		Set<LFTestCase> casesInLabel = DBUtil.getInstance()
				.getTestCasesForLabel(currentNode.getLabel().getLabel());
		if (casesInLabel != null && casesInLabel.size() > 0) {
			JOptionPane
			.showMessageDialog(
					AutoPilotAppl.getApplication().getMainFrame(),
					"Cannot delete a label with test cases in it, please move all test cases to another category before removing it.");
		} else {
			removeLabelFromFolderTree(currentNode);
			removeLabelFromPersistence(currentNode);
		}
	}



	protected void removeLabelFromFolderTree(TestCaseTreeNode labelNodeToRemv) {
		TestCaseTreeNode parent = (TestCaseTreeNode) (labelNodeToRemv
				.getParent());
		if (parent != null) {
			((DefaultTreeModel) testCaseTree.getModel())
					.removeNodeFromParent(labelNodeToRemv);
			decrementNodeCount(labelNode.getName());
			this.testcaseTreeNodeMap.remove(labelNodeToRemv.getName());
		}
		
		//remove sub label nodes under categories
		ArrayList<TestCaseTreeNode> labelNodesToRemove = findSubLabelNodesInTree(labelNodeToRemv.getName(), rootNode);
		for(TestCaseTreeNode n : labelNodesToRemove){
			((DefaultTreeModel) testCaseTree.getModel())
			.removeNodeFromParent(n);
		}
	}
	
	
	private ArrayList<TestCaseTreeNode> findSubLabelNodesInTree(String nodeName, TestCaseTreeNode startNode){
		
		ArrayList<TestCaseTreeNode> labelNodesToRemove = new ArrayList<TestCaseTreeNode>();
		
		findNodesInTree(labelNodesToRemove, nodeName, startNode, TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY);
		
		return labelNodesToRemove;
		
	}
	
	private void findNodesInTree(ArrayList<TestCaseTreeNode> foundNodes, String nodeName, TestCaseTreeNode startNode, TestCaseTreeNode.NodeType nodeType){
		
		if(startNode.getType().equals(nodeType) && startNode.getName().equals(nodeName)){
			foundNodes.add(startNode);
		}
		
		if(startNode.isLeaf()){
			return;
		}else{
			for(int i = 0 ; i < startNode.getChildCount(); i++){
				findNodesInTree(foundNodes, nodeName, (TestCaseTreeNode) startNode.getChildAt(i), nodeType);
			}
		}
	}

	protected void removeLabelFromPersistence(TestCaseTreeNode labelNode) {
		try {
			DBUtil.getInstance().removeFromDB(labelNode.getLabel());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected void addNewLabelMenuItemActionPerformed(ActionEvent evt) {
		createNewLabel();
	}

	public TestCaseTreeNode createNewLabel() {
		String labelName = (String) JOptionPane.showInputDialog(AutoPilotAppl
				.getApplication().getMainFrame(),
				"Please enter the name of the new label", "New Label",
				JOptionPane.QUESTION_MESSAGE, null, null, "");

		LFLabel newLabel = new LFLabel(labelName);
		newLabel.setLabelID(Util.getLabelIDSequencer());
		TestCaseTreeNode newLabelNode = new TestCaseTreeNode(newLabel);
		if (isValidNewNode(newLabelNode)) {
			addNewLabelToFolderTree(newLabelNode);
			addNewLabelToPersistence(newLabelNode);
		} else {
			JOptionPane
					.showMessageDialog(AutoPilotAppl.getApplication()
							.getMainFrame(),
							"Invalid category name or category is already existed, please try again.");
			return null;
		}

		return newLabelNode;
	}

	public void addTestCaseToLabel(String label, LFTestCase testCase) {
		try {
			DBUtil.getInstance().getLbm()
					.addTestCaseToLabel(label, testCase.getTestID());
			// TestCaseTreeNode labelNode =
			// ApplicationContext.getTestRunPanel().getTestCaseTreeNodeMap().get(label);
			// labelNode.incrementCaseCount();
			// ((DefaultTreeModel)
			// testCaseTree.getModel()).nodeChanged(labelNode);
			ApplicationContext.getTestRunPanel().incrementNodeCount(
					labelNode.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}



	private void addNewLabelToPersistence(TestCaseTreeNode newLabelNode) {
		try {
			DBUtil.getInstance().getLbm().saveLabel(newLabelNode.getLabel());
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private void addNewLabelToFolderTree(TestCaseTreeNode newLabelNode) {

		// add new label to the "Label" node
		((DefaultTreeModel) testCaseTree.getModel()).insertNodeInto(
				newLabelNode, labelNode, 0);
		ApplicationContext.getTestRunPanel().updateTreeNodeMap(newLabelNode);
		((DefaultTreeModel) testCaseTree.getModel()).nodeChanged(labelNode);

		// add new label to every category node
		for (TestCaseTreeNode categoryNode : testcaseTreeNodeMap.values()) {
			if (categoryNode.getType().equals(
					TestCaseTreeNode.NodeType.CATEGORY)) {
				TestCaseTreeNode labelNodeInCategory = new TestCaseTreeNode(
						categoryNode.getCategory(), newLabelNode.getLabel());
				((DefaultTreeModel) testCaseTree.getModel()).insertNodeInto(
						labelNodeInCategory, categoryNode, 0);
			}
		}

		// Make sure the user can see the lovely new node.
		testCaseTree.scrollPathToVisible(new TreePath(newLabelNode.getPath()));
	}

	protected void removeFromLabelMenuItemActionPerformed(ActionEvent evt) {

		int[] selectedRowIdxes = resultTable.getSelectedRows();
		TestCaseTreeNode selectedNode = (TestCaseTreeNode) testCaseTree
				.getLastSelectedPathComponent();
		TestCaseTreeNode labelNode = this.testcaseTreeNodeMap.get(selectedNode
				.getName());

		for (int idx : selectedRowIdxes) {
			LFTestCase testcase = results.get(resultTable
					.convertRowIndexToModel(idx));
			// removeTestCaseFromOriginalCategory(labelNode, testcase);
			try {
				DBUtil.getInstance()
						.getLbm()
						.removeLabelFromTestcase(
								labelNode.getLabel().getLabel(),
								testcase.getTestID());
				decrementNodeCount(labelNode.getLabel().getLabel());
				results.clear();
				results.addAll(DBUtil.getInstance().getTestCasesForLabel(
						labelNode.getLabel().getLabel()));
				clearTable();
				populateResultTable(results);
				((DefaultTreeModel) testCaseTree.getModel())
						.nodeChanged(labelNode);
			} catch (Exception e) {
				e.printStackTrace();
			}

		}

	}
	

	protected void renameTreeNodeMenuItemActionPerformed(ActionEvent evt) {
		String categoryName = (String) JOptionPane.showInputDialog(
				AutoPilotAppl.getApplication().getMainFrame(),
				"Please enter a new name for the node", "Rename Tree Node",
				JOptionPane.QUESTION_MESSAGE, null, null, "");

		TestCaseTreeNode oldNode = (TestCaseTreeNode) caseFolderTreePath
				.getLastPathComponent();

		if (oldNode.getType().equals(TestCaseTreeNode.NodeType.CATEGORY)) {

			TestCaseTreeNode newNode = new TestCaseTreeNode(new LFCategory(
					categoryName));
			if (isValidNewNode(newNode)) {
				// ArrayList<LFTestCase> caseList =
				// categoryToCaseMap.remove(oldNode);
				// oldNode.setName(categoryName);
				// categoryToCaseMap.put(oldNode, caseList);
				// ((DefaultTreeModel)
				// testCaseTree.getModel()).nodeChanged(oldNode);
				try {
					DBUtil.getInstance().getCtm()
							.deleteCategory(oldNode.getCategory());
					DBUtil.getInstance().getCtm()
							.saveCategory(newNode.getCategory());
					// TODO: remove the category of every cases that belong to
					// the old category
				} catch (Exception e) {
					e.printStackTrace();
				}

			} else {
				JOptionPane
						.showMessageDialog(AutoPilotAppl.getApplication()
								.getMainFrame(),
								"Invalid name or node name is already existed, please try again.");
			}
		} else if (oldNode.getType().equals(TestCaseTreeNode.NodeType.LABEL)) {

		}

	}

	protected void removeCaseCategoryActionPerformed(ActionEvent evt) {
		removeCaseCategory();
	}

	protected void removeCaseCategory() {
		TreePath currentSelection = testCaseTree.getSelectionPath();
		if (currentSelection != null) {
			TestCaseTreeNode currentNode = (TestCaseTreeNode) (currentSelection
					.getLastPathComponent());
			String category = currentNode.getName();
			List<LFTestCase> casesInCategory = DBUtil.getInstance().getTcm()
					.getTestcasesForCategory(category); // getTestCases("Category",
														// currentNode.getName());
			if (casesInCategory.size() > 0) {
				JOptionPane
						.showMessageDialog(
								AutoPilotAppl.getApplication().getMainFrame(),
								"Cannot delete a category with test cases in it, please move all test cases to another category before removing it.");
			} else {
				removeCaseCategoryFromFolderTree(currentNode);
				removeCaseCategoryFromPersistence(currentNode);
			}
		}
	}

	private void removeCaseCategoryFromPersistence(TestCaseTreeNode categoryNode) {
		// categoryToCaseMap.remove(categoryNode);
		//
		// for(Enumeration e = categoryNode.children() ; e.hasMoreElements() ;){
		// TestCaseTreeNode childNode = (TestCaseTreeNode)e.nextElement();
		// removeCaseCategoryFromPersistence(childNode);
		// }
		try {
			DBUtil.getInstance().getCtm()
					.deleteCategory(categoryNode.getCategory());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected void removeCaseCategoryFromFolderTree(
			TestCaseTreeNode categoryNode) {
		TestCaseTreeNode parent = (TestCaseTreeNode) (categoryNode.getParent());
		if (parent != null) {
			((DefaultTreeModel) testCaseTree.getModel())
					.removeNodeFromParent(categoryNode);
			this.testcaseTreeNodeMap.remove(categoryNode.getName());
			return;
		}
	}

	protected void addNewCaseCategoryActionPerformed(ActionEvent evt) {
		String categoryName = (String) JOptionPane.showInputDialog(
				AutoPilotAppl.getApplication().getMainFrame(),
				"Please enter the name of the new category", "New Category",
				JOptionPane.QUESTION_MESSAGE, null, null, "");

		TestCaseTreeNode newCategoryNode = new TestCaseTreeNode(new LFCategory(
				categoryName));
		if (isValidNewNode(newCategoryNode)) {
			this.addNewCaseCategoryToFolderTree(newCategoryNode);
			this.addNewCaseCategoryToPersistence(newCategoryNode);
			DBUtil.getInstance().getCtm().loadCategoryFromDB();
			DBUtil.getInstance().getTcm().loadCategoryFromDB();
		} else {
			JOptionPane
					.showMessageDialog(AutoPilotAppl.getApplication()
							.getMainFrame(),
							"Invalid category name or category is already existed, please try again.");
		}
	}

	private boolean isValidNewNode(TestCaseTreeNode node) {

		if (node == null || node.getName() == null
				|| node.getName().length() == 0) {
			return false;
		}

		if (node.getType().equals(TestCaseTreeNode.NodeType.CATEGORY)) {
			List<LFCategory> categories = DBUtil.getInstance().getCtm()
					.getCategoriesFromDB();
			if (node.getCategory() == null
					|| categories.contains(node.getCategory())) {
				return false;
			}

		} else if (node.getType().equals(TestCaseTreeNode.NodeType.LABEL)) {
			List<LFLabel> labels = DBUtil.getInstance().getLbm()
					.getLabelsFromDB();
			if (node.getLabel() == null || labels.contains(node.getLabel())) {
				return false;
			}
		}

		return true;
	}

	private void addNewCaseCategoryToFolderTree(TestCaseTreeNode childNode) {
		TestCaseTreeNode parentNode = null;
		TreePath parentPath = testCaseTree.getSelectionPath();

		if (parentPath == null) {
			// There is no selection. Default to the root node.
			parentNode = rootNode;
		} else {
			parentNode = (TestCaseTreeNode) (parentPath.getLastPathComponent());
		}

		((DefaultTreeModel) testCaseTree.getModel()).insertNodeInto(childNode,
				parentNode, 0);
		ApplicationContext.getTestRunPanel().updateTreeNodeMap(childNode);
		// Make sure the user can see the lovely new node.
		testCaseTree.scrollPathToVisible(new TreePath(childNode.getPath()));
	}

	private void addNewCaseCategoryToPersistence(
			TestCaseTreeNode newCategoryNode) {
		try {
			DBUtil.getInstance().getCtm()
					.saveCategory(newCategoryNode.getCategory());
			System.out.println("addNewCaseCategoryToPersistence");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void editMenuItemActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_editMenuItemActionPerformed
		try {
			setCursor(hourglassCursor);
			viewSelectedTestCase();
		} finally {
			setCursor(defaultCursor);
		}
	}

	private void viewSelectedTestCase() {
		ApplicationContext.getTestcaseHelper()
				.resetTestCaseChangesSavedStatus();
		updateInputTestCasePanelWithSelectedTestCase();
		((AutoPilotApplView) AutoPilotAppl.getApplication().getMainView())
				.showMainPanel();
	}

	public void updateInputTestCasePanelWithSelectedTestCase() {
		InputTestCasePanel inputTestCasePanel = ApplicationContext
				.getTestcasePanel();
		LFTestCase testcase = results.get(resultTable
				.convertRowIndexToModel(resultTable.getSelectedRow()));
		
		inputTestCasePanel.setTestcase(testcase);
	}

	private void doubleClickTestCasePerformed(java.awt.event.MouseEvent evt) {
		try {
			setCursor(hourglassCursor);
			viewSelectedTestCase();
		} finally {
			setCursor(defaultCursor);
		}

	}

	private void testCaseTreeMouseReleased(java.awt.event.MouseEvent evt) {

		if (evt.isPopupTrigger()) {
			int x = evt.getX();
			int y = evt.getY();
			caseFolderTreePath = testCaseTree.getPathForLocation(x, y);
			TestCaseTreeNode selectedNode = (TestCaseTreeNode) caseFolderTreePath
					.getLastPathComponent();

			// only popup for directory
			if (caseFolderTreePath != null) {

				addNewCategoryMenuItem.setVisible(false);
				renameTreeNodeMenuItem.setVisible(false);
				removeCategoryMenuItem.setVisible(false);
				addNewLabelMenuItem.setVisible(false);
				removeLabelMenuItem.setVisible(false);
				renameLabelMenuItem.setVisible(false);
				
				if (selectedNode.getType() == TestCaseTreeNode.NodeType.LABEL_FOLDER) {
					addNewLabelMenuItem.setVisible(true);

				} else if (selectedNode.getType() == TestCaseTreeNode.NodeType.ALL_CASES_DIR) { // SUB_ROOT
																								// or
																								// CATEGORY
					addNewCategoryMenuItem.setVisible(true);

				} else if (selectedNode.getType() == TestCaseTreeNode.NodeType.CATEGORY) {
					// renameTreeNodeMenuItem.setVisible(true);
					removeCategoryMenuItem.setVisible(true);
					
				} else if (selectedNode.getType() == TestCaseTreeNode.NodeType.LABEL) {
					// renameTreeNodeMenuItem.setVisible(true);
					removeLabelMenuItem.setVisible(true);
					renameLabelMenuItem.setVisible(true);
				}

				treePopupMenu.show(testCaseTree, x, y);
			}
		}
	}

	private void resultTableMouseReleased(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_resultTableMouseReleased
		if (evt.isPopupTrigger()) {
			// test if any valid case category is selected
			TestCaseTreeNode fromNode = (TestCaseTreeNode) testCaseTree
					.getLastSelectedPathComponent();

			if (fromNode != null
					&& (fromNode.getType().equals(
							TestCaseTreeNode.NodeType.LABEL) || fromNode
							.getType()
							.equals(TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY))) {
				removeFromLabelMenuItem.setVisible(true);
			} else {
				removeFromLabelMenuItem.setVisible(false);
			}

			resultTable = (JTable) evt.getComponent();
			resultTablePopupMenu.show(evt.getComponent(), evt.getX(),
					evt.getY());
		}
	}// GEN-LAST:event_resultTableMouseReleased

	private class TestRowFilter extends RowFilter<TestTableModel, Integer> {
		private String key;
		private String filter;
		private int col = -1;

		public TestRowFilter(String key, String filter) {
			this.key = key;
			this.filter = filter;
		}

		public boolean include(
				Entry<? extends TestTableModel, ? extends Integer> entry) {
			TestTableModel model = entry.getModel();
			if (col < 0) {
				for (int i = 0; i < model.getColumnCount(); i++)
					if (key.equals(model.getColumnName(i))) {
						col = i;
						break;
					}
			}
			if (col >= 0
					&& entry.getValue(col).toString().toLowerCase()
							.startsWith(filter.toLowerCase())) {
				return true;
			}
			return false;
		}
	}

	@SuppressWarnings("unchecked")
	private void applyTestCaseFilters() {
		TableRowSorter tableRowSorter = ((TableRowSorter) resultTable
				.getRowSorter());
		int fn = criteriaValue.trim().length() > 0 ? 1 : 0;
		fn += jTextField1.getText().trim().length() > 0 ? 1 : 0;
		fn += jTextField2.getText().trim().length() > 0 ? 1 : 0;
		fn += jTextField3.getText().trim().length() > 0 ? 1 : 0;
		if (fn > 0) {
			List<RowFilter<TestTableModel, Integer>> filters = new ArrayList<RowFilter<TestTableModel, Integer>>(
					fn);
			if (criteriaValue.trim().length() > 0)
				filters.add(new TestRowFilter(criteriaField, criteriaValue
						.trim()));
			if (jTextField1.getText().trim().length() > 0)
				filters.add(new TestRowFilter(jComboBox2.getSelectedItem()
						.toString(), jTextField1.getText().trim()));
			if (jTextField2.getText().trim().length() > 0)
				filters.add(new TestRowFilter(jComboBox3.getSelectedItem()
						.toString(), jTextField2.getText().trim()));
			if (jTextField3.getText().trim().length() > 0)
				filters.add(new TestRowFilter(jComboBox4.getSelectedItem()
						.toString(), jTextField3.getText().trim()));
			tableRowSorter.setRowFilter(RowFilter.andFilter(filters));
		} else {
			tableRowSorter.setRowFilter(null);
		}
	}

	private void filterButtonActionPerformed(java.awt.event.ActionEvent evt) {
		if (filterPanel.isVisible()) {
			filterPanel.setVisible(false);
		} else {
			filterPanel.setVisible(true);
		}
	}

	private void deleteMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
		try {
			AutoPilotAppl.getApplication().getMainFrame()
					.setCursor(hourglassCursor);
			LFTestCase testcase = results.get(resultTable
					.convertRowIndexToModel(resultTable.getSelectedRow()));
			removeAllLabelsInTestcase(testcase.getTestID());

			// update category node
			// TestCaseTreeNode categoryNode =
			// this.testcaseTreeNodeMap.get(testcase.getCategory());
			// TestCaseTreeNode allNode = this.testcaseTreeNodeMap.get("All");
			// categoryNode.decrementCaseCount();
			// allNode.decrementCaseCount();
			// ((DefaultTreeModel)
			// testCaseTree.getModel()).nodeChanged(categoryNode);
			// ((DefaultTreeModel)
			// testCaseTree.getModel()).nodeChanged(allNode);

			this.decrementNodeCount("All");
			this.decrementNodeCount(testcase.getCategory());

			DBUtil.getInstance().getTcm().deleteTestCase(testcase);
			logger.info("Testcase " + testcase.getTestID() + " deleted.");

			TestCaseTreeNode selectedNode = (TestCaseTreeNode) testCaseTree
					.getLastSelectedPathComponent();

			results.clear();

			// update result table
			if (selectedNode.getType().equals(TestCaseTreeNode.NodeType.LABEL)) {
				results.addAll(DBUtil.getInstance().getTestCasesForLabel(
						selectedNode.getLabel().getLabel()));
			} else if (selectedNode.getType().equals(
					TestCaseTreeNode.NodeType.CATEGORY)) {
				results.addAll(DBUtil
						.getInstance()
						.getTcm()
						.getTestcasesForCategory(
								selectedNode.getCategory().getCategory()));
			}
			else if(selectedNode.getType().equals(TestCaseTreeNode.NodeType.ALL_CASES_DIR))
			{
				results.addAll(DBUtil.getInstance().getTcm().getAllTestcases());
			}
			clearTable();
			populateResultTable(results);

			// loadTestCases(true);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			AutoPilotAppl.getApplication().getMainFrame()
					.setCursor(defaultCursor);
		}
	}

	private void okRunDialogButtonActionPerformed(java.awt.event.ActionEvent evt) {
		testRunDialog.setVisible(false);
	}

	private void enableAllCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {
		checkEnableAllCheckBox();
		chckbxEnableResultWindow.setSelected(true);
		chckbxEnableResultWindowActionPerformed(evt);
	}

	private void checkEnableAllCheckBox() {
		if (enableAllCheckBox.isSelected()) {
			tableModel.batchEnable(false);
		} else {
			tableModel.batchDisable();
		}
	}

	private void criteriaComboBoxActionPerformed(java.awt.event.ActionEvent evt) {
		if ("All".equals(mainFilterComboBox.getSelectedItem())) {
			searchTextField.setText("");
			searchTextField.setEditable(false);
		} else {
			searchTextField.setEditable(true);
		}
	}

	private void searchButtonActionPerformed(java.awt.event.ActionEvent evt) {
		loadTestCases(true);

	}

	public void loadTestCases(final boolean updateResultsFromDatabase) {
		loadTestCases(updateResultsFromDatabase, false);
	}
	

	public void loadTestCases(final boolean updateResultsFromDatabase, final boolean toPopulateFolderTree) {
		criteriaField = (String) mainFilterComboBox.getSelectedItem();
		criteriaValue = (String) searchTextField.getText();

		searchButton.setEnabled(false);

		SwingWorker<List<LFTestCase>, String> worker = new SwingWorker<List<LFTestCase>, String>() {
			@Override
			protected List<LFTestCase> doInBackground() throws Exception {
				if (updateResultsFromDatabase) {
					results = DBUtil.getInstance().getTestCases(criteriaField, criteriaValue);
				}
				clearTable();
				// applyTestCaseFilters(); - commenting out as it restricts the
				// ability to do a "like" search
				populateResultTable(results);
				if (toPopulateFolderTree) {
					populateFolderTree();
				}
				checkEnableAllCheckBox();
				return results;
			}

			public void done() {
				searchButton.setEnabled(true);
				
				// The try/catch block is a workaround to keep SwingWorker from swallowing exceptions
				// Source: http://jonathangiles.net/blog/?p=341
				try {
					get();
				} catch (InterruptedException e) {
					throw new RuntimeException(e);
				} catch (ExecutionException e) {
					throw new RuntimeException(e.getCause());
				}
			}
		};

		worker.execute();
	}
	
	public void loadTestCases(final boolean updateResultsFromDatabase, final boolean toPopulateFolderTree, final boolean toKeepOrigResult) {
		criteriaField = (String) mainFilterComboBox.getSelectedItem();
		criteriaValue = (String) searchTextField.getText();

		searchButton.setEnabled(false);

		SwingWorker<List<LFTestCase>, String> worker = new SwingWorker<List<LFTestCase>, String>() {
			@Override
			protected List<LFTestCase> doInBackground() throws Exception {
				if (updateResultsFromDatabase) {
					ArrayList<LFTestCase> tempResults = new ArrayList<LFTestCase>();
					for(LFTestCase c : results){
						tempResults.add(c);
					}
					results.clear();
					List<LFTestCase> casesFromDB = DBUtil.getInstance().getTestCases(criteriaField,
							criteriaValue);
					for(LFTestCase dbCase : casesFromDB){
						for(LFTestCase tempCase : tempResults){
							if(tempCase.getTestID().equals(dbCase.getTestID())){
								// not sure what this is??? dbCase.setFailed(tempCase);
								results.add(dbCase);
							}
						}
					}
					
				}
				clearTable();
				// applyTestCaseFilters(); - commenting out as it restricts the
				// ability to do a "like" search
				populateResultTable(results, toKeepOrigResult);
				if (toPopulateFolderTree) {
					populateFolderTree();
				}
				checkEnableAllCheckBox();
				return results;
			}

			public void done() {
				searchButton.setEnabled(true);

				// The try/catch block is a workaround to keep SwingWorker from swallowing exceptions
				// Source: http://jonathangiles.net/blog/?p=341
				try {
					get();
				} catch (InterruptedException e) {
					throw new RuntimeException(e);
				} catch (ExecutionException e) {
					throw new RuntimeException(e.getCause());
				}
			}
		};

		worker.execute();
	}

	private void populateResultTable(List<LFTestCase> s) {
		for (LFTestCase testcase : s) {
			tableModel.addRow(testcase);
		}
		tableModel.fireTableDataChanged();
	}
	
	private void populateResultTable(List<LFTestCase> s, boolean toKeepResultList) {
		for (int i = 0; i < s.size(); i++) {
			tableModel.addRow(s.get(i));
			// not sure what this is?? tableModel.updateResult(i, !s.get(i).isFailed());
		}
		tableModel.fireTableDataChanged();
	}

	public void populateFolderTree() {

//		List<LFTestCase> allCaseList = DBUtil.getInstance().getTcm()
//				.getAllTestcases();
		
		List<LFTestCase> allCaseList = results;

		// populate categories
		rootNode.removeAllChildren();
		// "All" node
		TestCaseTreeNode allCasesNode = new TestCaseTreeNode("All",
				TestCaseTreeNode.NodeType.ALL_CASES_DIR);
		ApplicationContext.getTestRunPanel().updateTreeNodeMap(allCasesNode);
		allCasesNode.setChildCount(allCaseList.size());
		rootNode.add(allCasesNode);

		// Other category nodes
		DBUtil.getInstance().getCtm().loadCategoryFromDB();
		List<LFCategory> categoryList = DBUtil.getInstance().getCtm()
				.getCategories();
		List<LFLabel> labelList = DBUtil.getInstance().getLbm().getLabels();
		for (LFCategory categ : categoryList) {
			TestCaseTreeNode categoryNode = new TestCaseTreeNode(categ);
			ApplicationContext.getTestRunPanel()
					.updateTreeNodeMap(categoryNode);
			allCasesNode.add(categoryNode);
			for (LFTestCase testcase : allCaseList) {
				if (testcase.getCategory().equals(categ.getCategory())) {
					categoryNode.incrementCaseCount();
				}
			}
			for (LFLabel lb : labelList) {
				TestCaseTreeNode newLabelNode = new TestCaseTreeNode(categ, lb);
				categoryNode.add(newLabelNode);
			}

		}

		// populate labels
		TestCaseTreeNode mainLabelNode = new TestCaseTreeNode("Labels",
				TestCaseTreeNode.NodeType.LABEL_FOLDER);
		this.labelNode = mainLabelNode;
		rootNode.add(mainLabelNode);
		for (LFLabel lb : labelList) {
			TestCaseTreeNode newLabelNode = new TestCaseTreeNode(lb);
			ApplicationContext.getTestRunPanel()
					.updateTreeNodeMap(newLabelNode);
			mainLabelNode.add(newLabelNode);
			newLabelNode.setChildCount(newLabelNode.getLabel().getTestcases()
					.size());
		}
		
		// populate release num;
		// populate labels
		TestCaseTreeNode releaseNumDirlNode = new TestCaseTreeNode("Releases",
				TestCaseTreeNode.NodeType.RELEASE_NUM_DIR);
		rootNode.add(releaseNumDirlNode);
		List<String> listOfReleaseNum = DBUtil.getInstance().getCtm().loadReleaseNumFromDB();
		for(String releaseNum : listOfReleaseNum){
			TestCaseTreeNode newReleaseNumNode = new TestCaseTreeNode(releaseNum, TestCaseTreeNode.NodeType.RELEASE_NUM_NODE);
			releaseNumDirlNode.add(newReleaseNumNode);
		}
		
		// populate release num;
		// populate labels
		TestCaseTreeNode jiraNumDirNode = new TestCaseTreeNode("JIRA Num",
				TestCaseTreeNode.NodeType.JIRA_NUM_DIR);
		rootNode.add(jiraNumDirNode);
		List<String> listOfJiraNum = DBUtil.getInstance().getCtm().loadJiraNumFromDB();
		for(String jiraNum : listOfJiraNum){
			if(jiraNum != null && (jiraNum.trim().length() > 0)){
				TestCaseTreeNode newReleaseNumNode = new TestCaseTreeNode(jiraNum, TestCaseTreeNode.NodeType.JIRA_NUM_NODE);
				jiraNumDirNode.add(newReleaseNumNode);
			}
		}
		
		testCaseTree.expandPath(new TreePath(mainLabelNode.getPath()));
		testCaseTree.expandPath(new TreePath(releaseNumDirlNode.getPath()));
	}

	private void clearTable() {
		tableModel.getData().clear();
	}

	public void run() {
		logger.info("Start Running Testcases ...");
		passNumLabel1.setText("0");
		failNumLabel1.setText("0");
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		Task task = new Task();
		task.addPropertyChangeListener(this);
		task.execute();
	}

	public void exportTestCasesToCSV()  {
		logger.info("Start exporting Testcases ...");
		JFileChooser fc = new JFileChooser();
		FileFilter filter = new FileNameExtensionFilter("CSV file", "csv");
		fc.addChoosableFileFilter(filter);
		int returnVal = fc.showOpenDialog(AutoPilotAppl.getApplication().getMainFrame()); //Where frame is the parent component
		File file = null;
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			if(fc.getSelectedFile().getPath().contains(".csv")){
				file = fc.getSelectedFile();
			}else{
				file = new File(fc.getSelectedFile().getPath() + ".csv");
			}
		    
			exportTestResultToFile(file);
			// create a pop up to notify user on successful exporting
			final JFrame frame = new JFrame();
			JOptionPane.showMessageDialog(frame, "Exported Successfully!!!");
		    
		} else {
		    //User did not choose a valid file
		}
		
		
	}
	public void exportTestResultToFile(File file)  {
		
		
		 try {
				BufferedWriter bw = new BufferedWriter(new FileWriter(file));
				// write header
				bw.write("Test Name," + "Test Objective,"+ "Label,"+ "Step#,"+ "Test Step Description," + "Expected Result" + "\r\n");
				// iterate over each ENABLED test case
				for(int i =0 ; i < tableModel.getRowCount(); i++){
					if (!tableModel.isCaseEnabled(i)) continue;
					
					//get the test case
					LFTestCase TestCaseObj = DBUtil.getInstance().getTestCase(tableModel.getTestCase(i));
					
					String TestName = (String)tableModel.getValueAt(i,3); // Test case name
					String newTestName = null;
					if(TestName != null)
						newTestName = TestName.replace(",", " "); // Very important to remove all "," to dump data correctly into a csv file.
					
					String TestObj = (String)tableModel.getValueAt(i,4); // Test Objective
					String newTestObj = null;
					if(TestObj != null )
						newTestObj = TestObj.replace(",", " "); // Very important to remove all "," to dump data correctly into a csv file.
								
					String labelArrayString = null; // find all labels that the test belong to
					for(LFLabel lb : DBUtil.getInstance().getLbm().getLabelsForTestcase(TestCaseObj.getTestID())){
						if( labelArrayString == null)
							labelArrayString = lb.getLabel();
						else
							labelArrayString = labelArrayString + ";"+lb.getLabel();
					}
					bw.write( newTestName + "," + newTestObj + "," + labelArrayString +"\r\n"); // Test Name , Test Objective , Test label
				
					// get all the input steps for a test case.
					List<LFTestInputSteps> TestInputStepsList = TestCaseObj.getInputStepList();
					for (int i2 = 0; i2 < TestInputStepsList.size(); i2++) {
						List<LFOutputMsg> TestOutputList =(TestInputStepsList.get(i2)).getOutputStepList();
						int StepNo = i2+1;
						// Specially handling the case where for an input step there is NO output list.
						if(TestOutputList.size() == 0)
						{
							
							String InputTemplate = (TestInputStepsList.get(i2)).getTemplate();
							String InputComment = (TestInputStepsList.get(i2)).getComments();
							String newInputComment = null;
							if(InputComment != null)
								newInputComment = InputComment.replace(",", " "); // Very important to remove all "," to dump data correctly into a csv file.
							String InputMessageType = (TestInputStepsList.get(i2)).getMsgType();
							String InputTopicID = (TestInputStepsList.get(i2)).getTopicID();
							List<LFTag> InputTagList = (TestInputStepsList.get(i2)).getInputTagsValueList();
							String InputTagValue = null ;
							for(int iITL = 0; iITL < InputTagList.size(); iITL++){
								String TagID = InputTagList.get(iITL).getTagID();
								String TagValue = InputTagList.get(iITL).getTagValue();
								if(InputTagValue == null)
									InputTagValue = TagID + "=" + TagValue;
								else
									InputTagValue = InputTagValue + ";" + TagID + "=" + TagValue;
							}
							
							bw.write( ","+","+","+StepNo +","+ InputTemplate + "|" + newInputComment  + "|" + InputTagValue + "|" + InputMessageType + "|" + InputTopicID + "\r\n"); // Test Step Desc = Template | Comments | TagID=Value | MsgType| Topic
						
						
						}
						else
						{
							// for an input step of a test case, iterate over all output steps
							
							for (int i3 = 0; i3 < TestOutputList.size(); i3++) {
							 						
							 	String InputTemplate = (TestInputStepsList.get(i2)).getTemplate();
								String InputComment = (TestInputStepsList.get(i2)).getComments();
								String newInputComment = null;
								if(InputComment != null)
									newInputComment = InputComment.replace(",", " "); // Very important to remove all "," to dump data correctly into a csv file.
								List<LFTag> InputTagList = (TestInputStepsList.get(i2)).getInputTagsValueList();
								String InputMessageType = (TestInputStepsList.get(i2)).getMsgType();
								String InputTopicID = (TestInputStepsList.get(i2)).getTopicID();
								String InputTagValue = null ;
								for(int iITL = 0; iITL < InputTagList.size(); iITL++){
									String TagID = InputTagList.get(iITL).getTagID();
									String TagValue = InputTagList.get(iITL).getTagValue();
									if(InputTagValue == null)
										InputTagValue = TagID + "=" + TagValue;
									else
										InputTagValue = InputTagValue + ";" + TagID + "=" + TagValue;
								}
								

							 String OutputTemplate = (TestOutputList.get(i3)).getTemplate();
							 String OutputTopicID = (TestOutputList.get(i3)).getTopicID();

							 String OutputTagValue = null;
							 List<LFOutputTag> OutputTagList = (TestOutputList.get(i3)).getOutputTagList();
							 for(int iOTL = 0; iOTL < OutputTagList.size(); iOTL++){
								 String TagID = OutputTagList.get(iOTL).getTagID();
								 String TagValue = OutputTagList.get(iOTL).getTagValue();
								 if(OutputTagValue == null)
										OutputTagValue = TagID + "=" + TagValue;
									else
										OutputTagValue = OutputTagValue + ";" + TagID + "=" + TagValue;
								 
									
							 }
							 // Step# , Test Step Desc , Expected Result
							 // Step# = for a test case on which input test step we are 
							 // Test Step Desc = Template | Comments | TagID=Value | MsgType| Topic
							 // Expected Result = Template | TopicID| TagID=Value  
							 bw.write( ","+","+","+StepNo +","+ InputTemplate + "|" + newInputComment  + "|" + InputTagValue +"|" + InputMessageType + "|" + InputTopicID + ","+ OutputTemplate + "|" + OutputTopicID + "|" +OutputTagValue + "\r\n"); 
						 } 
					 }
				}

				}
				
				bw.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		    //Now you have your file to do whatever you want to do	
	}
	
		
	
	
	public void rerun() {
		logger.info("Start Re-Running Testcases ...");
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		ReRun task = new ReRun();
		task.addPropertyChangeListener(this);
		task.execute();
	}

	public void propertyChange(PropertyChangeEvent e) {

		if ("progress" == e.getPropertyName()) {
			int progress = (Integer) e.getNewValue();
			testProgressBar.setValue(progress);
			logger.info("Progrss : " + progress + "%");
		} else if ("state".equals(e.getPropertyName())) {
			StateValue state = (StateValue) (e.getNewValue());
			switch (state) {
			case STARTED:
				testProgressBar.setValue(0);
				break;

			}
		}
	}

	public void enableCaseFolder() {
		folderTree_scrollPane.setVisible(true);
		panel.setVisible(true);
	}

	public void disableCaseFolder() {
		folderTree_scrollPane.setVisible(false);
		panel.setVisible(false);
	}

	public void setPauseTimeBetweenCases(int pauseTime) {
		this.pauseTimeBetweenCases = pauseTime;
	}

	public void enableResultsTable() {
		this.isResultTableEnabled = true;
	}

	public void disableResultTable() {
		this.isResultTableEnabled = true;
	}

	public boolean isResultTableEnabled() {
		return this.isResultTableEnabled;
	}

	private void showResultTable() {
		if (isResultTableEnabled) {
			JFrame mainFrame = AutoPilotAppl.getApplication().getMainFrame();
			TestResultsDialog resultsDialog = new TestResultsDialog(mainFrame,
					false);
			resultsDialog.populateResultTables(selectedTestcases);
			resultsDialog.setLocationRelativeTo(mainFrame);
			AutoPilotAppl.getApplication().show(resultsDialog);
		}

	}

	public void refreshTestCaseTableByTreeSelection() {

		TestCaseTreeNode node = (TestCaseTreeNode) testCaseTree
				.getLastSelectedPathComponent();
		// ArrayList<LFTestCase> caseList = categoryToCaseMap.get(node);
		List<LFTestCase> tempCaseList = new ArrayList<LFTestCase>();
		if (node != null) {
			if (node.getType().equals(TestCaseTreeNode.NodeType.CATEGORY)) {
				String category = node.getName();
				tempCaseList = DBUtil.getInstance().getTcm()
						.getTestcasesForCategory(category); // getTestCases("Category",
															// node.getName());
			} else if (node.getType().equals(
					TestCaseTreeNode.NodeType.ALL_CASES_DIR)) {
				tempCaseList = DBUtil.getInstance().getTcm().getAllTestcases();
			} else if (node.getType().equals(TestCaseTreeNode.NodeType.LABEL)) {
				Set<LFTestCase> result = DBUtil.getInstance().getTestCasesForLabel(node.getLabel().getLabel());

				// we want to sort the testcases by name
				tempCaseList.addAll(Util.asSortedList(result, new Comparator<LFTestCase>() {
					@Override
					public int compare(LFTestCase o1, LFTestCase o2) {
						return o1.getName().compareTo(o2.getName());
					}
					
				}));
			} else if (node.getType().equals(
					TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY)) {
				return;
			} else if (node.getType().equals(TestCaseTreeNode.NodeType.RELEASE_NUM_NODE)) {
				tempCaseList.addAll(DBUtil.getInstance().getTcm().getTestcasesForReleaseNum(node.getName()));
			} else if (node.getType().equals(TestCaseTreeNode.NodeType.JIRA_NUM_NODE)) {
				tempCaseList.addAll(DBUtil.getInstance().getTcm().getTestcasesForJiraNum(node.getName()));
			}
			
		}

		results = tempCaseList;
		clearTable();
		populateResultTable(results);
	}

	public TreePath getTreePathFromNode(TestCaseTreeNode node) {
		List<TestCaseTreeNode> list = new ArrayList<TestCaseTreeNode>();

		while (node != null) {
			list.add(node);
			node = (TestCaseTreeNode) node.getParent();
		}
		Collections.reverse(list);
		return new TreePath(list.toArray());
	}

	public void updateTreeNodeMap(TestCaseTreeNode node) {
		this.testcaseTreeNodeMap.put(node.getName(), node);
	}

	public HashMap<String, TestCaseTreeNode> getTestCaseTreeNodeMap() {
		return this.testcaseTreeNodeMap;
	}

	public void incrementNodeCount(String nodeName) {
		TestCaseTreeNode node = this.testcaseTreeNodeMap.get(nodeName);
		if (node != null) {
			node.incrementCaseCount();
			((DefaultTreeModel) testCaseTree.getModel()).nodeChanged(node);
		}
	}

	public void decrementNodeCount(String nodeName) {
		TestCaseTreeNode node = this.testcaseTreeNodeMap.get(nodeName);
		if (node != null) {
			node.decrementCaseCount();
			((DefaultTreeModel) testCaseTree.getModel()).nodeChanged(node);
		}
	}

	public void removeAllLabelsInTestcase(String testID) throws Exception {
		List<LFLabel> labelsInTestcase = DBUtil.getInstance().getLbm()
				.getLabelsForTestcase(testID);
		for (LFLabel lb : labelsInTestcase) {
			DBUtil.getInstance().getLbm()
					.removeLabelFromTestcase(lb.getLabel(), testID);
			// TestCaseTreeNode labelNode =
			// this.getTestCaseTreeNodeMap().get(lb.getLabel());
			// labelNode.decrementCaseCount();
			// ((DefaultTreeModel)
			// testCaseTree.getModel()).nodeChanged(labelNode);
			this.decrementNodeCount(lb.getLabel());

		}

	}

	class Task extends SwingWorker<Void, Void>{

		@Override
		protected Void doInBackground() throws Exception {
			double progress = 0;
			setProgress(0);
			int totalCaseCount = 0;
			pass = 0;
			fail = 0;
			selectedTestcases.clear();

			for (int i =0 ; i < tableModel.getRowCount(); i ++){
				tableModel.resetResult(i);
				if (!tableModel.isCaseEnabled(i)) continue;
				totalCaseCount += tableModel.getRepeatTimes(i);
			}

			for(int i =0 ; i < tableModel.getRowCount(); i ++){
				if (!tableModel.isCaseEnabled(i)) continue;
				for(int j = 0; j< tableModel.getRepeatTimes(i); j++){
					ValidationObject validationObject = TestCaseController.INSTANCE.runPersistedTestCase(tableModel.getTestCase(i), symbolTextField.getText(),false);
					
					selectedTestcases.add(validationObject);

					if(validationObject.isSuccess()){
						pass++; 
						passNumLabel1.setText(String.valueOf(pass));
					}else{
						fail++;
						failNumLabel1.setText(String.valueOf(fail));
					}

					tableModel.updateResult(i, validationObject.isSuccess());

					try {
						Thread.sleep(pauseTimeBetweenCases);
					} catch (Exception e) {

					}
					
					double incr = 100.0/(double)totalCaseCount;
					progress += incr;
					setProgress ((int)Math.round(progress));
				}


			}

			return null;
		}

		/*
		 * Executed in event dispatching thread
		 */
		@Override
		public void done() {
			Toolkit.getDefaultToolkit().beep();
			setCursor(null); // turn off the wait cursor
			logger.info("Finish Running Testcases ...");

			passNumLabel.setText(String.valueOf(pass));
			failNumLabel.setText(String.valueOf(fail));

			ApplicationContext.getResultPanel().reload(selectedTestcases);

			ApplicationContext.getTestRunPanel().showResultTable();
			// The try/catch block is a workaround to keep SwingWorker from swallowing exceptions
			// Source: http://jonathangiles.net/blog/?p=341
			try {
				get();
			} catch (InterruptedException e) {
				throw new RuntimeException(e);
			} catch (ExecutionException e) {
				throw new RuntimeException(e.getCause());
			}
		}

	}
	
	class ReRun extends SwingWorker<Void, Void> {
		@Override
		protected Void doInBackground() throws Exception {
			
			double progress = 0;
			setProgress(0);
			pass = Integer.parseInt(passNumLabel1.getText());
			fail = Integer.parseInt(failNumLabel1.getText());
			int totalCaseCount = fail;

			for (int i = 0; i < tableModel.getRowCount(); i++) {
				if (!tableModel.isCaseEnabled(i))
					continue;
			}

			System.out.println("Rerun, # of selected cases is: " + selectedTestcases.size());
			test:
			for (int i = 0; i < tableModel.getRowCount(); i++) {
				if (!tableModel.isCaseEnabled(i))
					continue;
				
				// if validationObject status = passed for the test case, continue to next case
				for(ValidationObject vo : selectedTestcases){
					if(vo.getTestcase().getTestID().equals(tableModel.getTestCase(i))){
						if(vo.isSuccess()){
							continue test;
						}
					}
					
				}
				
				for (int j = 0; j < tableModel.getRepeatTimes(i); j++) {
					
					symbol = symbolTextField.getText();
					
					ValidationObject validationObject = TestCaseController.INSTANCE.runPersistedTestCase(tableModel.getTestCase(i), symbol,false);
					
					selectedTestcases.set(i, validationObject);

					if (validationObject.isSuccess()) {
						pass++;
						fail--;
						passNumLabel1.setText(String.valueOf(pass));
						failNumLabel1.setText(String.valueOf(fail));
					} 

					tableModel.updateResult(i, validationObject.isSuccess());
					try {
						Thread.sleep(pauseTimeBetweenCases);
					} catch (Exception e) {

					}

					double incr = 100.0 / (double) totalCaseCount;
					progress += incr;
					setProgress((int) Math.round(progress));
				}

			}

			return null;
		}
		
		/*
		 * Executed in event dispatching thread
		 */
		@Override
		public void done() {
			Toolkit.getDefaultToolkit().beep();
			setCursor(null); // turn off the wait cursor
			logger.info("Finish Re-Running Testcases ...");
			
			passNumLabel.setText(String.valueOf(pass));
			failNumLabel.setText(String.valueOf(fail));

			ApplicationContext.getResultPanel().reload(selectedTestcases);

			ApplicationContext.getTestRunPanel().showResultTable();

			// The try/catch block is a workaround to keep SwingWorker from swallowing exceptions
			// Source: http://jonathangiles.net/blog/?p=341
			try {
				get();
			} catch (InterruptedException e) {
				throw new RuntimeException(e);
			} catch (ExecutionException e) {
				throw new RuntimeException(e.getCause());
			}
		}
	}

	class APRowFilter extends RowFilter<TestTableModel, Integer> {

		@Override
		public boolean include(
				Entry<? extends TestTableModel, ? extends Integer> entry) {
			TestTableModel model = entry.getModel();
			Object[] testcaseRow = model.getData().get(entry.getIdentifier());

			if ("NEW".equalsIgnoreCase((String) testcaseRow[1])) {
				return true;
			}

			return false;
		}

	}

	class TestCaseTreeSelectionListener implements TreeSelectionListener {

		public void valueChanged(TreeSelectionEvent e) {
			refreshTestCaseTableByTreeSelection();
		}
	}

	class TestCaseTreeModelChangedListener implements TreeModelListener {

		@Override
		public void treeNodesChanged(TreeModelEvent arg0) {
			// System.out.println(testCaseTree.getSelectionPath());
			// refreshTestCaseTableByTreeSelection();

		}

		@Override
		public void treeNodesInserted(TreeModelEvent arg0) {
			// TODO Auto-generated method stub
		}

		@Override
		public void treeNodesRemoved(TreeModelEvent arg0) {
			// TODO Auto-generated method stub
		}

		@Override
		public void treeStructureChanged(TreeModelEvent arg0) {
			// TODO Auto-generated method stub
		}

	}

	class TableTransferHandler extends TransferHandler {

		public int getSourceActions(JComponent c) {
			return TransferHandler.COPY_OR_MOVE;
		}

		protected Transferable createTransferable(JComponent c) {
			return new StringSelection(exportString(c));
		}

		// Bundle up the selected items in the JTable
		// as a single string, for export.
		protected String exportString(JComponent c) {

			int[] selectedRowIdxes = resultTable.getSelectedRows();

			StringBuffer outputBuffer = new StringBuffer();
			for (int idx : selectedRowIdxes) {
				LFTestCase testcase = results.get(resultTable.convertRowIndexToModel(idx));
				outputBuffer.append(testcase.getTestID() + "|");
			}
			return outputBuffer.toString();

		}

		protected void exportDone(JComponent c, Transferable data, int action) {

			if (action == TransferHandler.MOVE) {
				if (c.equals(resultTable)) {
					// TODO: remove test case from the dragged category
				}
			}

		}

		public boolean canImport(TransferHandler.TransferSupport info) {
			// Check for String flavor
			if (!info.isDataFlavorSupported(DataFlavor.stringFlavor)) {
				return false;
			}

			String data = "";
			try {
				data = (String) info.getTransferable().getTransferData(
						DataFlavor.stringFlavor);
				if (!data.startsWith("label_")) {
					return false;
				}

			} catch (UnsupportedFlavorException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}

			return true;
		}

		public boolean importData(TransferHandler.TransferSupport info) {
			// if we can't handle the import, say so
			if (!canImport(info)) {
				return false;
			}

			// fetch the data and bail if this fails
			String filterLabel;
			try {
				filterLabel = ((String)info.getTransferable().getTransferData(DataFlavor.stringFlavor)).replace("label_", "");
			} catch (UnsupportedFlavorException e) {
				return false;
			} catch (IOException e) {
				return false;
			}
			
			for (Iterator<LFTestCase> it = results.iterator(); it.hasNext(); ){
				if(!it.next().containsLabel(filterLabel)){
					it.remove();
				}
			}
			
			clearTable();
			populateResultTable(results);

			return true;
		}
	}

	class TreeTransferHandler extends TransferHandler {

		public int getSourceActions(JComponent c) {
			return TransferHandler.MOVE;
		}

		protected Transferable createTransferable(JComponent c) {
			return new StringSelection(exportString(c));
		}

		// Bundle up the selected items in the JTable
		// as a single string, for export.
		protected String exportString(JComponent c) {
			// JTable table = (JTable)c;
			TestCaseTreeNode fromNode = (TestCaseTreeNode) testCaseTree
					.getLastSelectedPathComponent();

			if (fromNode.getType().equals(TestCaseTreeNode.NodeType.CATEGORY)) {

				return "category_"
						+ ((TestCaseTreeNode) testCaseTree
								.getLastSelectedPathComponent()).getName();

			} else if (fromNode.getType().equals(
					TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY)) {

				return "label_"
						+ ((TestCaseTreeNode) testCaseTree
								.getLastSelectedPathComponent()).getName();

			}

			return "";

		}

		protected void exportDone(JComponent c, Transferable data, int action) {

			// clear moved node
			if (action == TransferHandler.MOVE) {
				// TestCaseTreeNode oldNode = (TestCaseTreeNode)
				// testCaseTree.getLastSelectedPathComponent();
				// ((DefaultTreeModel)
				// testCaseTree.getModel()).removeNodeFromParent(oldNode);
				// TODO: update database
			}

		}

		public boolean canImport(TransferHandler.TransferSupport info) {
			// check for String flavor
			if (!info.isDataFlavorSupported(DataFlavor.stringFlavor)) {
				return false;
			}

			// fetch the drop location
			JTree.DropLocation dl = (JTree.DropLocation) info.getDropLocation();

			TreePath path = dl.getPath();

			// we don't support invalid paths or non-category folder drop
			if (path == null) {
				return false;
			}

			String data = "";
			try {
				data = (String) info.getTransferable().getTransferData(DataFlavor.stringFlavor);
			} catch (Throwable t) {
			}
			
			TestCaseTreeNode fromNode = (TestCaseTreeNode) testCaseTree.getLastSelectedPathComponent();
			TestCaseTreeNode toNode = (TestCaseTreeNode) path.getLastPathComponent();

			// don't allow dragging within folder tree
			if (data.startsWith("category_")) {
				return false;
			}
			
			if (fromNode != null) {
				// can't drag to the same
				if (fromNode.equals(toNode)) {
					return false;
				}
				
				switch(fromNode.getType()) {
				case CATEGORY:
				case RELEASE_NUM_DIR:
				case RELEASE_NUM_NODE:
				case JIRA_NUM_DIR:
				case JIRA_NUM_NODE:
					return false;
				}
			}

			
			switch(toNode.getType()) {
			case CATEGORY:
			case RELEASE_NUM_DIR:
			case RELEASE_NUM_NODE:
			case JIRA_NUM_DIR:
			case JIRA_NUM_NODE:
				return false;
			}

			return true;
		}

		public boolean importData(TransferHandler.TransferSupport info) {
			try {
			
				// if we can't handle the import, say so
				if (!canImport(info)) {
					return false;
				}
	
				// fetch the data and bail if this fails
				String data;
				try {
					data = (String) info.getTransferable().getTransferData(
							DataFlavor.stringFlavor);
				} catch (UnsupportedFlavorException e) {
					return false;
				} catch (IOException e) {
					return false;
				}
	
				JTree.DropLocation dl = (JTree.DropLocation) info.getDropLocation();
				// fetch the path from the drop location
				TreePath path = dl.getPath();
	
				TestCaseTreeNode fromNode = (TestCaseTreeNode) testCaseTree
						.getLastSelectedPathComponent();
				TestCaseTreeNode toNode = (TestCaseTreeNode) path
						.getLastPathComponent();
	
				// TestCaseTreeNode targetNode =
				// ((TestCaseTreeNode)path.getLastPathComponent());
				String[] testIdTokens = data.split("\\|");
	
				if (toNode.getType().equals(TestCaseTreeNode.NodeType.LABEL)) {
					String toLabel = toNode.getLabel().getLabel();
					for (String testID : testIdTokens) {
						try {
							DBUtil.getInstance().getLbm()
									.addTestCaseToLabel(toLabel, testID);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					// update case count
	
					toNode.setChildCount(DBUtil.getInstance()
							.getTestCasesForLabel(toLabel).size());
	
				} else if (toNode.getType().equals(
						TestCaseTreeNode.NodeType.LABEL_IN_CATEGORY)) {
	
					String toLabel = toNode.getLabel().getLabel();
					for (String testID : testIdTokens) {
						try {
							DBUtil.getInstance().getLbm()
									.addTestCaseToLabel(toLabel, testID);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					// update case count
	
					TestCaseTreeNode labelNode = testcaseTreeNodeMap.get(toNode
							.getLabel().getLabel());
					labelNode.setChildCount(DBUtil.getInstance()
							.getTestCasesForLabel(toLabel).size());
					((DefaultTreeModel) testCaseTree.getModel())
							.nodeChanged(labelNode);
				} else if (toNode.getType().equals(
						TestCaseTreeNode.NodeType.CATEGORY)) {
					String category = fromNode.getName();
	//				ArrayList<LFTestCase> allCasesInCategory = (ArrayList<LFTestCase>) DBUtil
	//						.getInstance().getTcm()
	//						.getTestcasesForCategory(category);// getTestCases("Category",
	//															// fromNode.getName());
					List<LFTestCase> allCasesInCategory = DBUtil.getInstance().getTestCases("Category", category);
					ArrayList<LFTestCase> casesToUpdate = new ArrayList<LFTestCase>();
					for (String targetTestCaseID : testIdTokens) {
						for (LFTestCase testCase : allCasesInCategory) {
	
							if (testCase.getTestID().equals(targetTestCaseID)) {
								testCase.setCategory(toNode.getName());
								try {
									int tempSize =  testCase.getInputStepList().size(); //actively load test case input steps
									casesToUpdate.add(testCase);
	//								DBUtil.getInstance().updateDB(testCase);
									// update case count
									fromNode.decrementCaseCount();
									toNode.incrementCaseCount();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						}
					}
					
					for(LFTestCase c: casesToUpdate){
						try {
							DBUtil.getInstance().updateDB(c);
						} catch (Exception e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					
					
					
				}
	
				// bb85369 don't know why we clear the results and reload (results could be a search) next drag and drop becomes broken as result is empty (fromNode is null)
				/*results.clear();
				// update result table
				if (fromNode.getType().equals(TestCaseTreeNode.NodeType.CATEGORY) && fromNode.getType().equals(TestCaseTreeNode.NodeType.CATEGORY)) {
					results.addAll(DBUtil.getInstance().getTcm().getTestcasesForCategory(fromNode.getCategory().getCategory()));
				}
				
				clearTable();
				populateResultTable(results);
				*/
				
				((DefaultTreeModel) testCaseTree.getModel()).nodeChanged(toNode);
				((DefaultTreeModel) testCaseTree.getModel()).nodeChanged(fromNode);
	
				return true;
			} catch(Throwable t) {
				logger.severe(Util.getStackTrace(t));
			}
			
			return false;
		}
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JMenuItem copyMenuItem;
	private javax.swing.JComboBox mainFilterComboBox;
	private javax.swing.JLabel mainFilterLabel;
	private javax.swing.JMenuItem cutMenuItem;
	private javax.swing.JMenuItem removeFromLabelMenuItem;
	private javax.swing.JMenuItem editMenuItem;
	private javax.swing.JMenuItem deleteMenuItem;
	private javax.swing.JMenuItem addNewCategoryMenuItem;
	private javax.swing.JMenuItem removeCategoryMenuItem;
	private javax.swing.JMenuItem renameTreeNodeMenuItem;
	private javax.swing.JMenuItem addNewLabelMenuItem;
	private javax.swing.JMenuItem removeLabelMenuItem;
	private javax.swing.JMenuItem renameLabelMenuItem;
	// private javax.swing.JMenuItem pasteSelectedCasesMenuItem;
	// private javax.swing.JMenuItem copySelectedCasesMenuItem;
	private javax.swing.JCheckBox enableAllCheckBox;
	private javax.swing.JLabel failLabel;
	private javax.swing.JLabel failLabel1;
	private javax.swing.JLabel failNumLabel;
	private javax.swing.JLabel failNumLabel1;
	private javax.swing.AbstractButton showFilterPanel;
	private javax.swing.JPanel filterPanel;
	private javax.swing.JComboBox jComboBox2;
	private javax.swing.JComboBox jComboBox3;
	private javax.swing.JComboBox jComboBox4;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JLabel jLabel2;
	private javax.swing.JLabel jLabel3;
	private javax.swing.JTextField jTextField1;
	private javax.swing.JTextField jTextField2;
	private javax.swing.JTextField jTextField3;
	private javax.swing.JButton okRunDialogButton;
	private javax.swing.JLabel passLabel;
	private javax.swing.JLabel passLabel1;
	private javax.swing.JLabel passNumLabel;
	private javax.swing.JLabel passNumLabel1;
	private javax.swing.JMenuItem pasteMenuItem;
	private javax.swing.JScrollPane resultScrollPane;
	private javax.swing.JTable resultTable;
	private javax.swing.JPopupMenu resultTablePopupMenu;
	private javax.swing.JButton searchButton;
	private javax.swing.JTextField searchTextField;
	private javax.swing.JLabel symbolLabel;
	private javax.swing.JTextField symbolTextField;
	private javax.swing.JSeparator tableProgressbarSeparator;
	private javax.swing.JProgressBar testProgressBar;
	private javax.swing.JDialog testRunDialog;
	private javax.swing.JLabel titleLabel;
	// End of variables declaration//GEN-END:variables

	private TestTableModel tableModel = new TestTableModel();
	private String criteriaField;
	private String criteriaValue;
	private int pass;
	private int fail;
	private String symbol;
	public List<LFTestCase> results;
	private List<ValidationObject> selectedTestcases = new ArrayList<ValidationObject>();
	private Cursor hourglassCursor;
	private Cursor defaultCursor;
	private boolean isResultTableEnabled;

	private int pauseTimeBetweenCases;

	// private TreeDragSource ds;
	// private TreeDropTarget dt;
	private JScrollPane folderTree_scrollPane;
	private JTree testCaseTree;
	private JPopupMenu treePopupMenu;
	private TreePath caseFolderTreePath;
	private TestCaseTreeNode rootNode;
	private TestCaseTreeNode labelNode;

	// TODO: for demo purposes only, to be removed
	private HashMap<String, TestCaseTreeNode> testcaseTreeNodeMap = new HashMap<String, TestCaseTreeNode>();

	private JPanel panel;
	private JCheckBox chckbxEnableResultWindow;
}
